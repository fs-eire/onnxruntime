diff --git a/src/cmake/DawnCompilerPlatformFlags.cmake b/src/cmake/DawnCompilerPlatformFlags.cmake
index 50638e2456..efa42711e6 100644
--- a/src/cmake/DawnCompilerPlatformFlags.cmake
+++ b/src/cmake/DawnCompilerPlatformFlags.cmake
@@ -63,7 +63,3 @@ endif ()
 if (MSVC AND NOT COMPILER_IS_CLANG_CL)
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /MP")
 endif ()
-
-if (TARGET_MACOS)
-    set(CMAKE_OSX_DEPLOYMENT_TARGET "11.0" CACHE STRING "Minimum macOS version" FORCE)
-endif ()
\ No newline at end of file
diff --git a/third_party/emdawnwebgpu/library_webgpu.js b/third_party/emdawnwebgpu/library_webgpu.js
index 5a86163947..cd7c6a7cf9 100644
--- a/third_party/emdawnwebgpu/library_webgpu.js
+++ b/third_party/emdawnwebgpu/library_webgpu.js
@@ -832,6 +832,61 @@ var LibraryWebGPU = {
     {{{ runtimeKeepalivePush() }}}
     WebGPU.Internals.futureInsert(futureId, adapter.requestDevice(desc).then((device) => {
       {{{ runtimeKeepalivePop() }}}
+
+      if (globalThis["WEBGPU_STAT"]) {
+        // a set that caches all active buffers
+        const buffers = WebGPU.Internals.buffers ??= new Set();
+        // key is buffer usage, value is total size of buffers with that usage
+        const buffersTotalSize = WebGPU.Internals.buffersTotalSize ??= new Map();
+
+        WebGPU.Internals.buffersCreated ??= 0;
+        WebGPU.Internals.buffersDestroyed ??= 0;
+        WebGPU.Internals.buffersUploads ??= 0;
+        WebGPU.Internals.buffersExternalUploads ??= 0;
+        WebGPU.Internals.buffersDownloads ??= 0;
+        WebGPU.Internals.buffersExternalDownloads ??= 0;
+
+        // create a proxy so that we can monitor buffer usages
+        device = new Proxy(device, {
+          // when call device.createBuffer(), the returned buffer should be added into buffers
+          get: (target, prop, _receiver) => {
+            if (prop === 'createBuffer') {
+              return (desc) => {
+                const buffer = target.createBuffer(desc);
+                const originalDestroy = buffer.destroy.bind(buffer);
+                buffer.destroy = () => {
+                  const previousTotal = buffersTotalSize.get(buffer.usage);
+                  buffersTotalSize.set(buffer.usage, previousTotal - buffer.size);
+                  buffers.delete(buffer);
+                  WebGPU.Internals.buffersDestroyed++;
+                  originalDestroy();
+                };
+
+                if (buffer.usage === (GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC)) {
+                  WebGPU.Internals.buffersUploads++;
+                }
+                if (buffer.usage === (GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ)) {
+                  WebGPU.Internals.buffersDownloads++;
+                }
+
+                buffers.add(buffer);
+                const previousTotal = buffersTotalSize.get(buffer.usage) ?? 0;
+                buffersTotalSize.set(buffer.usage, previousTotal + buffer.size);
+                WebGPU.Internals.buffersCreated++;
+                return buffer;
+              };
+            }
+            const propertyValue = Reflect.get(target, prop);
+            if (typeof propertyValue === 'function') {
+              return propertyValue.bind(target);
+            } else {
+              return propertyValue;
+            }
+          },
+          set: (target, prop, value, _receiver) => Reflect.set(target, prop, value),
+        });
+      }
+
       WebGPU.Internals.jsObjectInsert(queuePtr, device.queue);
       WebGPU.Internals.jsObjectInsert(devicePtr, device);
 
diff --git a/third_party/emdawnwebgpu/webgpu.cpp b/third_party/emdawnwebgpu/webgpu.cpp
index 5bfac41dcc..71a153daaa 100644
--- a/third_party/emdawnwebgpu/webgpu.cpp
+++ b/third_party/emdawnwebgpu/webgpu.cpp
@@ -692,6 +692,7 @@ struct WGPUBufferImpl final : public EventSource,
   WGPUBufferImpl(const EventSource* source, bool mappedAtCreation);
   // Injection constructor used when we already have a backing Buffer.
   WGPUBufferImpl(const EventSource* source, WGPUBufferMapState mapState);
+  ~WGPUBufferImpl();
 
   void Destroy();
   const void* GetConstMappedRange(size_t offset, size_t size);
@@ -1361,6 +1362,12 @@ WGPUBufferImpl::WGPUBufferImpl(const EventSource* source,
       RefCountedWithExternalCount(kImportedFromJS),
       mMapState(mapState) {}
 
+WGPUBufferImpl::~WGPUBufferImpl() {
+  if (!IsImported()) {
+    Destroy();
+  }
+}
+
 void WGPUBufferImpl::Destroy() {
   emwgpuBufferDestroy(this);
   AbortPendingMap("Buffer was destroyed before mapping was resolved.");
